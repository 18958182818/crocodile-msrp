/*
 * Crocodile MSRP - https://github.com/crocodilertc/crocodile-msrp
 * Copyright (c) 2013 Crocodile RCS Ltd
 * http://www.crocodilertc.net
 * Released under the MIT license - see LICENSE.TXT
 */

var CrocMSRP = (function(CrocMSRP) {
	
	/**
	 * Creates a new DirectConnection, based around a WebRTC PeerConnection.
	 * <p>
	 * A single connection can support multiple sessions, each with its own
	 * DataChannel.
	 * 
	 * @class Represents a single connection to a websocket MSRP relay.
	 */
	function DirectConnection(peerConnection, config) {
		var option, defaultConfig = new CrocMSRP.ConnectionConfig();

		// Process any optional configuration options
		if (config) {
			// Copy in defaults for any missing options
			for (option in defaultConfig) {
				if (config[option] === undefined) {
					config[option] = defaultConfig[option];
				}
			}
		} else {
			// Use the defaults
			config = defaultConfig;
		}
		this.config = config;
		
		this.pc = peerConnection;
		// Map of data channel stream ids to session objects 
		this.sessions = {};
		
		// An array of active message senders
		this.activeSenders = [];
		// The count of outstanding sends
		this.outstandingSends = 0;
		this.nextForcedStreamId = 1;
	}

	/**
	 * Creates a new session that uses this connection.
	 * 
	 * @param {String} [label]
	 * The label to apply to the created DataChannel.  This can be anything; it
	 * is primarily useful for debugging purposes.
	 * @returns {CrocMSRP.DataChannelSession}
	 */
	DirectConnection.prototype.createSession = function(label) {
		var streamId = null;

		if (!this.pc.remoteDescription) {
			// Cannot determine stream ID from DTLS role, so force the value
			streamId = this.nextForcedStreamId++;
		}
		// Create the DataChannel
		var dataChannel = this.pc.createDataChannel(label, {
			protocol: 'MSRP',
			negotiated: true,
			id: streamId
		});

		var session = new CrocMSRP.DataChannelSession(this, dataChannel);
		this.sessions[dataChannel.id] = session;
		
		return session;
	};

	/**
	 * Augments a PeerConnection SDP offer to include details of MSRP
	 * sessions.
	 * <p>
	 * While any MSRP session remains established, all offers generated by the
	 * PeerConnection must be augmented by passing them to this method;
	 * otherwise the remote endpoint has to assume the sessions have ended.
	 * 
	 * @param {RTCSessionDescription} rtcSessionDescription
	 * The SDP offer created by the local PeerConnection.
	 */
	DirectConnection.prototype.augmentSdp = function(rtcSessionDescription) {
		var sdp, mline = null;

		if (CrocMSRP.util.isEmpty(this.sessions)) {
			// Nothing to do here
			return;
		}

		sdp = new CrocMSRP.Sdp.Session(rtcSessionDescription.sdp);
		if (!sdp) {
			console.warn('Failed to parse provided sdp:\n', rtcSessionDescription.sdp);
			return;
		}
		
		// Find the SCTP media line
		for (var index = 0, len = sdp.media.length; index < len; index++) {
			mline = sdp.media[index];
			if (mline.media === 'application' && mline.proto === 'DTLS/SCTP') {
				break;
			}
		}

		if (index >= len) {
			console.warn('Cannot find SCTP media line:\n', rtcSessionDescription.sdp);
			return;
		}

		// Add the m-line attributes
		var dcPort = mline.format;
		// TODO: There could be multiple SCTP ports defined for this association.
		// We should be referring to the sctpmap attribute to determine which
		// one is the WebRTC datachannel.
		for (var id in this.sessions) {
			this.sessions[id].addSdpAttributes(mline, dcPort, rtcSessionDescription.type);
		}

		rtcSessionDescription.sdp = sdp.toString(); 
	};
	
	/**
	 * Processes an SDP (offer or answer) sent to the PeerConnection hosting the
	 * MSRP session.  The SDP must have been successfully applied to the
	 * PeerConnection (using setRemoteDescription) before calling this method.
	 * <p>
	 * While sessions remain established, all answers received by the
	 * PeerConnection must be passed to this method.
	 * 
	 * @param {RTCSessionDescription} rtcSessionDescription
	 * The SDP offer/answer received from the far end.
	 */
	DirectConnection.prototype.setRemoteDescription = function(rtcSessionDescription) {
		var sdp, mline = null;

		sdp = new CrocMSRP.Sdp.Session(rtcSessionDescription.sdp);
		if (!sdp) {
			// Close any existing sessions
			this.close();
			console.warn('Failed to parse provided sdp:', rtcSessionDescription.sdp);
			return;
		}
		
		// Find the SCTP media line
		for (var index = 0, len = sdp.media.length; index < len; index++) {
			mline = sdp.media[index];
			if (mline.media === 'application' && mline.proto === 'DTLS/SCTP') {
				break;
			}
		}

		if (index >= len) {
			// Close any existing sessions
			this.close();
			console.warn('Cannot find SCTP media line:', rtcSessionDescription.sdp);
			return;
		}

		if (mline.port === 0) {
			// Close any existing sessions
			this.close();
			return;
		}

		// Find the data channel SCTP port
		var dcPort = null;
		var sctpmap = mline.attributes['sctpmap'];

		if (!sctpmap) {
			// Close any existing sessions
			this.close();
			return;
		}

		for (index = 0, len = sctpmap.length; index < len; index++) {
			var map = sctpmap[index].split(' ');
			if (map[1] === 'webrtc-datachannel') {
				dcPort = map[0];
				break;
			}
		}

		if (!dcPort) {
			// Close any existing sessions
			this.close();
			return;
		}

		// Find any MSRP streams in the data channel
		var msrpStreams = [];
		var dca = CrocMSRP.Sdp.parseDataChannelAttributes(mline.attributes);
		for (var stream in dca[dcPort]) {
			if (dca[dcPort][stream].subprotocol === 'MSRP') {
				msrpStreams.push(stream);
			}
		}

		// Parse the sub-protocol attributes
		var spa = CrocMSRP.Sdp.parseDataChannelSubProtocolAttributes(mline.attributes);
		var dcStreams = spa[dcPort];
		if (!dcStreams) {
			// Close any existing sessions
			this.close();
			return;
		}

		// Update existing streams
		for (stream in this.sessions) {
			// Close any session whose stream id is not present in the SDP
			if (msrpStreams.indexOf(stream) < 0 || !dcStreams[stream]) {
				this.sessions[stream].close();
				continue;
			}

			// Update the session
			this.sessions[stream].sdpUpdate(rtcSessionDescription.type, dcStreams[stream]);
		}

		if (rtcSessionDescription.type === 'offer') {
			// Check for new streams
			for (index = 0, len = msrpStreams.length; index < len; index++) {
				stream = msrpStreams[index];
				if (dcStreams[stream] && !this.sessions[stream]) {
					// Create the DataChannel
					var label = dca[dcPort][stream].label;
					var dataChannel = this.pc.createDataChannel(label, {
						protocol: 'MSRP',
						negotiated: true,
						id: stream
					});
					var session = new CrocMSRP.DataChannelSession(this, dataChannel);
					session.sdpUpdate(rtcSessionDescription.type, dcStreams[stream]);
					this.sessions[stream] = session;
					CrocMSRP.util.fireEvent(this, 'onSession', [session]);
				}
			}
		}
	};
	
	/**
	 * Closes all sessions associated with this connection.
	 */
	DirectConnection.prototype.close = function() {
		for (var id in this.sessions) {
			this.sessions[id].close();
		}
	};

	// Internal Events
	DirectConnection.prototype.removeSession = function(id) {
		delete this.sessions[id];
	};

	CrocMSRP.DirectConnection = DirectConnection;

	return CrocMSRP;
}(CrocMSRP || {}));
